```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LofiLand</title>
  <style>
    :root{
      --bg:#05070b;
      --panel:#0b1220;
      --panel2:#0a0f1a;
      --ink:#cfe8ff;
      --muted:#6aa0c8;
      --line:rgba(103,217,255,.18);
      --line2:rgba(103,217,255,.28);
      --shadow: rgba(0,0,0,.45);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 35% 20%, rgba(103,217,255,.08), transparent 60%),
        radial-gradient(900px 600px at 80% 75%, rgba(176,107,255,.08), transparent 55%),
        var(--bg);
      color:var(--ink);
      font-family: var(--mono);
      letter-spacing:.2px;
    }

    .app{
      max-width: 1100px;
      margin: 22px auto;
      padding: 16px;
      display:grid;
      gap:14px;
    }

    .frame{
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent 40%), var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: 0 18px 40px var(--shadow);
      overflow:hidden;
      position:relative;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid var(--line);
    }
    .title{
      font-size: 18px;
      font-weight: 700;
      letter-spacing: .6px;
    }
    .pill{
      padding: 6px 10px;
      border: 1px solid var(--line2);
      background: rgba(0,0,0,.18);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      min-width: 120px;
      text-align:right;
    }

    .sceneWrap{
      position:relative;
      background:#02040a;
    }
    .scene{
      aspect-ratio: 16 / 9;
      width:100%;
      position:relative;
      overflow:hidden;
    }
    video#bgVideo{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      filter: saturate(1.05) contrast(1.05);
    }
    canvas#sceneCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      pointer-events:none;
      mix-blend-mode: screen;
      opacity: 0.22;
    }
    .sceneLabel{
      position:absolute;
      left: 12px;
      bottom: 12px;
      padding: 7px 10px;
      border: 1px solid var(--line);
      background: rgba(5,7,11,.55);
      border-radius: 999px;
      font-size: 12px;
      color: var(--ink);
    }

    /* waveform: full width directly under video */
    .wave{
      padding: 10px 12px 12px 12px;
      border-top: 1px solid var(--line);
      background: rgba(0,0,0,.12);
    }
    canvas#wave{
      width:100%;
      height:82px;
      display:block;
      border-radius: 12px;
      border: 1px solid rgba(103,217,255,.10);
      background: rgba(3,6,12,.55);
    }

    .controls{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 14px;
      padding: 14px;
    }

    .panel{
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px;
    }

    h3{
      margin:0 0 10px 0;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btnRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    button, select{
      border-radius: 12px;
      font-family: var(--mono);
      font-size: 12px;
    }

    button{
      background: rgba(103,217,255,.08);
      border: 1px solid var(--line);
      color: var(--ink);
      padding: 10px 12px;
      cursor:pointer;
    }
    button:hover{ border-color: rgba(103,217,255,.40); }
    button:active{ transform: translateY(1px); }

    /* readable dropdown */
    select{
      background: rgba(3,6,12,.92);
      border: 1px solid rgba(103,217,255,.35);
      color: var(--ink);
      padding: 10px 36px 10px 12px;
      cursor:pointer;
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(207,232,255,.95) 50%),
        linear-gradient(135deg, rgba(207,232,255,.95) 50%, transparent 50%),
        linear-gradient(to right, rgba(103,217,255,.18), rgba(103,217,255,.18));
      background-position:
        calc(100% - 18px) calc(50% - 3px),
        calc(100% - 12px) calc(50% - 3px),
        calc(100% - 34px) 50%;
      background-size: 6px 6px, 6px 6px, 1px 18px;
      background-repeat:no-repeat;
    }
    select:focus{
      outline:none;
      border-color: rgba(103,217,255,.65);
      box-shadow: 0 0 0 3px rgba(103,217,255,.14);
    }
    option{ background:#05070b; color:var(--ink); }

    .grid{ display:grid; gap:10px; margin-top: 10px; }
    .control{
      display:grid;
      grid-template-columns: 120px 1fr 52px;
      align-items:center;
      gap:10px;
      font-size: 12px;
    }
    input[type="range"]{ width:100%; }
    .val{ color: var(--muted); text-align:right; }

    .sceneBtns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 10px;
    }

    @media (max-width: 900px){
      .controls{ grid-template-columns: 1fr; }
      .pill{ min-width: 90px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="frame">
      <div class="topbar">
        <div class="title">LofiLand</div>
        <div class="pill" id="status">Idle.</div>
      </div>

      <div class="sceneWrap">
        <div class="scene">
          <video id="bgVideo" muted playsinline loop preload="auto"></video>
          <canvas id="sceneCanvas"></canvas>
          <div class="sceneLabel" id="sceneLabel">Scene: Ramen Rain</div>
        </div>

        <div class="wave">
          <canvas id="wave" width="1200" height="90"></canvas>
        </div>
      </div>

      <div class="controls">
        <div class="panel">
          <div class="btnRow">
            <select id="pack">
              <option value="lofi">Lo-fi</option>
              <option value="deepfi">Deepfi</option>
              <option value="spacehop">Spacehop</option>
            </select>
            <button id="play">Play</button>
            <button id="pause">Pause</button>
            <button id="shuffle">Soft Shuffle</button>
          </div>

          <div class="sceneBtns">
            <button data-scene="ramen">Ramen Rain</button>
            <button data-scene="capsule">Capsule Desk</button>
            <button data-scene="submarine">Submarine Drift</button>
          </div>
        </div>

        <div class="panel">
          <h3>Mix</h3>
          <div class="grid">
            <div class="control"><div>Music</div><input id="trackVol" type="range" min="0" max="1" step="0.01" value="0.80"/><div class="val" id="trackVolV">0.80</div></div>
            <div class="control"><div>Rain</div><input id="rainVol" type="range" min="0" max="1" step="0.01" value="0.35"/><div class="val" id="rainVolV">0.35</div></div>
            <div class="control"><div>Conversation</div><input id="convVol" type="range" min="0" max="1" step="0.01" value="0.30"/><div class="val" id="convVolV">0.30</div></div>
            <div class="control"><div>Vinyl</div><input id="vinylVol" type="range" min="0" max="1" step="0.01" value="0.15"/><div class="val" id="vinylVolV">0.15</div></div>

            <div class="control"><div>Variety</div><input id="variety" type="range" min="0" max="1" step="0.01" value="0.35"/><div class="val" id="varietyV">0.35</div></div>

            <h3 style="margin:12px 0 0 0;">CRT</h3>
            <div class="control"><div>Muffle</div><input id="muffle" type="range" min="0" max="1" step="0.01" value="0.25"/><div class="val" id="muffleV">0.25</div></div>
            <div class="control"><div>Wobble</div><input id="wobble" type="range" min="0" max="1" step="0.01" value="0.20"/><div class="val" id="wobbleV">0.20</div></div>
            <div class="control"><div>Glow</div><input id="glow" type="range" min="0" max="1" step="0.01" value="0.30"/><div class="val" id="glowV">0.30</div></div>
            <div class="control"><div>Vignette</div><input id="vignette" type="range" min="0" max="1" step="0.01" value="0.35"/><div class="val" id="vignetteV">0.35</div></div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
  const $ = (id) => document.getElementById(id);

  // ===== CDN CONFIG =====
  // If assets feel cached, set REF to a commit hash.
  const USER = "justslashn";
  const REPO = "LofiLand";
  const REF  = "main";
  const CDN  = `https://cdn.jsdelivr.net/gh/${USER}/${REPO}@${REF}/`;
  // ======================

  const STEMS = ["drums","bass","chords","melody"];
  const BARS_PER_LOOP = 4; // your loop files are treated as 4 bars unless you change this

  const statusEl = $("status");
  const sceneLabel = $("sceneLabel");
  const bgVideo = $("bgVideo");

  const ui = {
    pack: $("pack"),
    play: $("play"),
    pause: $("pause"),
    shuffle: $("shuffle"),

    trackVol: $("trackVol"),
    rainVol: $("rainVol"),
    convVol: $("convVol"),
    vinylVol: $("vinylVol"),
    variety: $("variety"),

    muffle: $("muffle"),
    wobble: $("wobble"),
    glow: $("glow"),
    vignette: $("vignette")
  };

  const uiVals = {
    trackVolV: $("trackVolV"),
    rainVolV: $("rainVolV"),
    convVolV: $("convVolV"),
    vinylVolV: $("vinylVolV"),
    varietyV: $("varietyV"),
    muffleV: $("muffleV"),
    wobbleV: $("wobbleV"),
    glowV: $("glowV"),
    vignetteV: $("vignetteV"),
  };

  function setStatus(msg){ statusEl.textContent = msg; }

  function bindValue(el, out){
    const sync = () => out.textContent = Number(el.value).toFixed(2);
    el.addEventListener("input", sync);
    sync();
  }

  Object.entries({
    trackVol: "trackVolV",
    rainVol: "rainVolV",
    convVol: "convVolV",
    vinylVol: "vinylVolV",
    variety: "varietyV",
    muffle: "muffleV",
    wobble: "wobbleV",
    glow: "glowV",
    vignette: "vignetteV"
  }).forEach(([k, vk]) => bindValue(ui[k], uiVals[vk]));

  // ===== Scene video mapping =====
  // Put your mp4s here if/when you add them:
  // e.g. /scenes/ramen.mp4 in your repo.
  const SCENE_VIDEOS = {
    ramen: `${CDN}scenes/ramen.mp4`,
    capsule: `${CDN}scenes/capsule.mp4`,
    submarine: `${CDN}scenes/submarine.mp4`
  };
  // ===============================

  let sceneMode = "ramen";
  function setScene(mode){
    sceneMode = mode;
    sceneLabel.textContent =
      "Scene: " + (mode === "ramen" ? "Ramen Rain" : mode === "capsule" ? "Capsule Desk" : "Submarine Drift");

    // Video is muted so autoplay works. Your music comes from stems.
    const src = SCENE_VIDEOS[mode];
    bgVideo.src = src;
    bgVideo.muted = true;
    bgVideo.loop = true;
    bgVideo.playsInline = true;

    // Try to play (wonâ€™t throw if blocked)
    bgVideo.play().catch(() => {});
  }

  document.querySelectorAll("button[data-scene]").forEach(btn => {
    btn.addEventListener("click", () => setScene(btn.dataset.scene));
  });

  // Start with a scene
  setScene("ramen");

  // ===== Audio engine =====
  let ac = null;
  let master = null;

  let trackBus = null;
  let fxRain = null, fxConv = null, fxVinyl = null;
  let filter = null;

  let wobbleLFO = null, wobbleGain = null;

  let analyser = null;
  let data = null;

  let fxBuffers = {};
  let fxSources = {};

  let stemBuffers = { drums: [], bass: [], chords: [], melody: [] };
  let stemChannelGain = {};
  let stemActive = {}; // { stem: { src, gainNode, variantIndex } }
  let arrangement = { drums:true, bass:true, chords:true, melody:true };

  let isPlaying = false;
  let loopDur = 0;
  let playStartTime = 0;

  let arrangerTimeout = null;
  let arrangerInterval = null;

  async function ensureAudio(){
    if(ac) return;
    ac = new (window.AudioContext || window.webkitAudioContext)();

    master = ac.createGain();
    master.gain.value = 0.9;
    master.connect(ac.destination);

    trackBus = ac.createGain();
    trackBus.gain.value = parseFloat(ui.trackVol.value);

    filter = ac.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 16000;

    analyser = ac.createAnalyser();
    analyser.fftSize = 2048;
    data = new Uint8Array(analyser.fftSize);

    trackBus.connect(filter);
    filter.connect(analyser);
    analyser.connect(master);

    fxRain = ac.createGain(); fxRain.gain.value = parseFloat(ui.rainVol.value);
    fxConv = ac.createGain(); fxConv.gain.value = parseFloat(ui.convVol.value);
    fxVinyl = ac.createGain(); fxVinyl.gain.value = parseFloat(ui.vinylVol.value);
    fxRain.connect(master);
    fxConv.connect(master);
    fxVinyl.connect(master);

    wobbleLFO = ac.createOscillator();
    wobbleGain = ac.createGain();
    wobbleLFO.type = "sine";
    wobbleLFO.frequency.value = 0.25;
    wobbleGain.gain.value = 0.0;
    wobbleLFO.connect(wobbleGain);
    wobbleLFO.start();

    setStatus("Audio ready.");
  }

  async function fetchJson(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error("Missing file: " + url);
    return await res.json();
  }

  async function loadBuffer(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error("Missing file: " + url);
    const arr = await res.arrayBuffer();
    return await ac.decodeAudioData(arr);
  }

  function makeLoopSource(buffer, destination){
    const src = ac.createBufferSource();
    src.buffer = buffer;
    src.loop = true;
    src.connect(destination);
    return src;
  }

  function stopAll(){
    for (const k of Object.keys(fxSources)) {
      try { fxSources[k].stop(); } catch {}
    }
    fxSources = {};

    for (const s of Object.keys(stemActive)) {
      try { stemActive[s].src.stop(); } catch {}
    }
    stemActive = {};

    isPlaying = false;
  }

  function stopArranger(){
    if(arrangerTimeout){ clearTimeout(arrangerTimeout); arrangerTimeout = null; }
    if(arrangerInterval){ clearInterval(arrangerInterval); arrangerInterval = null; }
  }

  function nextLoopBoundaryTime(){
    const now = ac.currentTime;
    const elapsed = Math.max(0, now - playStartTime);
    const n = Math.ceil(elapsed / loopDur);
    return playStartTime + n * loopDur;
  }

  function connectWobbleToActive(){
    try { wobbleGain.disconnect(); } catch {}
    if (stemActive.melody?.src) wobbleGain.connect(stemActive.melody.src.playbackRate);
    if (stemActive.chords?.src) wobbleGain.connect(stemActive.chords.src.playbackRate);
  }

  function startStem(stemName, variantIndex, when, fadeSeconds = 0.12){
    const bufArr = stemBuffers[stemName];
    if (!bufArr || bufArr.length === 0) return;

    const buf = bufArr[variantIndex];

    const g = ac.createGain();
    g.gain.setValueAtTime(0, when);
    g.gain.linearRampToValueAtTime(1, when + fadeSeconds);
    g.connect(stemChannelGain[stemName]);

    const src = ac.createBufferSource();
    src.buffer = buf;
    src.loop = true;
    src.connect(g);
    src.start(when);

    const old = stemActive[stemName];
    if (old?.gainNode && old?.src) {
      old.gainNode.gain.setValueAtTime(old.gainNode.gain.value, when);
      old.gainNode.gain.linearRampToValueAtTime(0, when + fadeSeconds);
      try { old.src.stop(when + fadeSeconds + 0.03); } catch {}
    }

    stemActive[stemName] = { src, gainNode: g, variantIndex };
  }

  function pickDifferentVariantIndex(stemName){
    const n = stemBuffers[stemName]?.length ?? 0;
    if (n <= 1) return stemActive[stemName]?.variantIndex ?? 0;
    const current = stemActive[stemName]?.variantIndex ?? 0;

    let next = current;
    for (let tries = 0; tries < 10 && next === current; tries++) {
      next = Math.floor(Math.random() * n);
    }
    return next;
  }

  function existsStem(s){
    return (stemBuffers[s]?.length ?? 0) > 0;
  }

  async function loadPack(packName){
    await ensureAudio();
    stopArranger();
    stopAll();

    stemBuffers = { drums: [], bass: [], chords: [], melody: [] };
    fxBuffers = {};

    const packBase = `${CDN}packs/${packName}/`;
    const fxBase = `${CDN}fx/`;
    const manifestUrl = `${packBase}manifest.json`;

    setStatus("Loading manifest...");
    const manifest = await fetchJson(manifestUrl);

    const stemFiles = {};
    for (const s of STEMS) stemFiles[s] = Array.isArray(manifest[s]) ? manifest[s] : [];

    if ((stemFiles.drums?.length ?? 0) === 0) {
      throw new Error(`Manifest has no "drums" entries: ${manifestUrl}`);
    }

    setStatus("Loading stems...");
    for (const s of STEMS) {
      stemBuffers[s] = [];
      for (const f of stemFiles[s]) {
        stemBuffers[s].push(await loadBuffer(packBase + f));
      }
    }

    loopDur = stemBuffers.drums[0].duration;

    // FX (fixed filenames)
    fxBuffers.rain  = await loadBuffer(fxBase + "rain.mp3");
    fxBuffers.conv  = await loadBuffer(fxBase + "cafe_chatter.mp3");
    fxBuffers.vinyl = await loadBuffer(fxBase + "vinyl_noise.mp3");

    arrangement = {
      drums: stemBuffers.drums.length > 0,
      bass: stemBuffers.bass.length > 0,
      chords: stemBuffers.chords.length > 0,
      melody: stemBuffers.melody.length > 0
    };

    const counts = STEMS.map(s => `${s}:${stemBuffers[s].length}`).join(", ");
    setStatus(`Loaded ${packName}. Variants: ${counts}`);
  }

  function updateAudioFromUI(){
    if(!ac) return;

    trackBus.gain.setTargetAtTime(parseFloat(ui.trackVol.value), ac.currentTime, 0.03);
    fxRain.gain.setTargetAtTime(parseFloat(ui.rainVol.value), ac.currentTime, 0.03);
    fxConv.gain.setTargetAtTime(parseFloat(ui.convVol.value), ac.currentTime, 0.03);
    fxVinyl.gain.setTargetAtTime(parseFloat(ui.vinylVol.value), ac.currentTime, 0.03);

    const m = parseFloat(ui.muffle.value);
    const freq = 800 + (16000 - 800) * Math.pow(1 - m, 2.2);
    filter.frequency.setTargetAtTime(freq, ac.currentTime, 0.05);

    const w = parseFloat(ui.wobble.value);
    wobbleGain.gain.setTargetAtTime(w * 0.004, ac.currentTime, 0.05);
  }

  function startAll(){
    if(isPlaying) return;

    const t0 = ac.currentTime + 0.10;
    playStartTime = t0;

    stemChannelGain = {};
    for (const s of STEMS) {
      if ((stemBuffers[s]?.length ?? 0) === 0) continue;
      const g = ac.createGain();
      g.gain.value = arrangement[s] ? 1 : 0;
      g.connect(trackBus);
      stemChannelGain[s] = g;
    }

    for (const s of STEMS) {
      if (!stemChannelGain[s]) continue;
      startStem(s, 0, t0, 0.08);
    }

    fxSources.rain  = makeLoopSource(fxBuffers.rain, fxRain);
    fxSources.conv  = makeLoopSource(fxBuffers.conv, fxConv);
    fxSources.vinyl = makeLoopSource(fxBuffers.vinyl, fxVinyl);
    Object.values(fxSources).forEach(src => src.start(t0));

    connectWobbleToActive();

    isPlaying = true;
    setStatus("Playing.");
    startArranger();
  }

  function shuffleWithIntensity(v){
    arrangement = {
      drums: true,
      bass: existsStem("bass") ? (Math.random() > 0.15 * v) : false,
      chords: existsStem("chords") ? (Math.random() > 0.25 * v) : false,
      melody: existsStem("melody") ? (Math.random() > 0.45 * v) : false
    };

    for (const s of STEMS) {
      if (!stemChannelGain[s]) continue;
      stemChannelGain[s].gain.setTargetAtTime(arrangement[s] ? 1 : 0, ac.currentTime, 0.08);
    }

    const when = nextLoopBoundaryTime();
    for (const s of STEMS) {
      if (!stemChannelGain[s]) continue;
      if (Math.random() > v) continue;

      const nextIdx = pickDifferentVariantIndex(s);
      const curIdx = stemActive[s]?.variantIndex ?? 0;
      if (nextIdx !== curIdx) startStem(s, nextIdx, when, 0.12);
    }

    setTimeout(connectWobbleToActive, 150);
  }

  function forceOneSwap(){
    const when = nextLoopBoundaryTime();
    const candidates = STEMS.filter(s => stemChannelGain[s] && (stemBuffers[s]?.length ?? 0) > 1);
    if(candidates.length === 0){
      shuffleWithIntensity(1.0);
      return;
    }
    const pick = candidates[Math.floor(Math.random() * candidates.length)];
    const nextIdx = pickDifferentVariantIndex(pick);
    const curIdx = stemActive[pick]?.variantIndex ?? 0;
    if(nextIdx !== curIdx) startStem(pick, nextIdx, when, 0.12);

    setTimeout(connectWobbleToActive, 150);
  }

  function startArranger(){
    stopArranger();
    if(!loopDur || !isFinite(loopDur) || loopDur <= 0) return;

    // Every 4 bars: derive bar duration from loop duration.
    const barDur = loopDur / BARS_PER_LOOP;
    const intervalMs = barDur * 4 * 1000;

    const now = ac.currentTime;
    const elapsed = Math.max(0, now - playStartTime);

    const barsElapsed = elapsed / barDur;
    const next4 = Math.ceil(barsElapsed / 4) * 4;
    const firstWhen = playStartTime + next4 * barDur;

    const delayMs = Math.max(0, (firstWhen - now) * 1000);

    arrangerTimeout = setTimeout(() => {
      arrangerTick();
      arrangerInterval = setInterval(arrangerTick, intervalMs);
    }, delayMs);
  }

  function arrangerTick(){
    if(!isPlaying) return;

    const v = parseFloat(ui.variety.value);
    if(!(v > 0)) return;

    if(v >= 0.999){
      forceOneSwap();
      setStatus("Auto-variation (1.00): next boundary.");
      return;
    }

    if(Math.random() > v) return;
    shuffleWithIntensity(v);
    setStatus(`Auto-variation (${v.toFixed(2)}): next boundary.`);
  }

  // ===== Wire UI events (buttons must work) =====
  ["trackVol","rainVol","convVol","vinylVol","muffle","wobble","variety"].forEach(k => {
    ui[k].addEventListener("input", () => {
      updateAudioFromUI();
      if (k === "variety" && isPlaying) startArranger();
    });
  });

  ui.play.addEventListener("click", async () => {
    try{
      await ensureAudio();
      if(ac.state === "suspended") await ac.resume();

      // ensure background video keeps playing
      bgVideo.play().catch(() => {});

      await loadPack(ui.pack.value);
      updateAudioFromUI();
      startAll();
    }catch(err){
      setStatus("Error: " + err.message);
      console.error(err);
    }
  });

  ui.pause.addEventListener("click", () => {
    if(!ac) return;
    stopArranger();
    stopAll();
    setStatus("Paused.");
  });

  ui.shuffle.addEventListener("click", () => {
    if(!isPlaying) return;
    shuffleWithIntensity(1.0);
    setStatus("Soft shuffle: next boundary.");
  });

  ui.pack.addEventListener("change", async () => {
    if(!ac) return;
    await loadPack(ui.pack.value);
    updateAudioFromUI();
    if(isPlaying) startAll();
  });

  // ===== Minimal CRT overlay (canvas) =====
  const sceneCanvas = $("sceneCanvas");
  const sctx = sceneCanvas.getContext("2d");
  function resizeCanvasToCSS(c){
    const r = c.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    c.width = Math.floor(r.width * dpr);
    c.height = Math.floor(r.height * dpr);
  }
  window.addEventListener("resize", () => resizeCanvasToCSS(sceneCanvas));

  let tt = 0;
  function drawCRT(){
    resizeCanvasToCSS(sceneCanvas);
    const w = sceneCanvas.width, h = sceneCanvas.height;
    tt += 0.016;

    const glow = parseFloat(ui.glow.value);
    const vig = parseFloat(ui.vignette.value);

    sctx.clearRect(0,0,w,h);

    // scanlines
    sctx.globalAlpha = 0.08 + glow * 0.10;
    sctx.fillStyle = "rgba(120,220,255,0.18)";
    for(let y=0;y<h;y+=6){
      sctx.fillRect(0,y,w,1);
    }

    // subtle noise
    sctx.globalAlpha = 0.06 + glow * 0.06;
    for(let i=0;i<160;i++){
      const x = ((i*97 + tt*400) % w);
      const y = ((i*53 + tt*260) % h);
      sctx.fillRect(x,y,2,1);
    }

    // vignette
    sctx.globalAlpha = 0.25 + vig * 0.55;
    const grd = sctx.createRadialGradient(w*0.5,h*0.5, Math.min(w,h)*0.25, w*0.5,h*0.5, Math.max(w,h)*0.68);
    grd.addColorStop(0, "rgba(0,0,0,0)");
    grd.addColorStop(1, "rgba(0,0,0,1)");
    sctx.fillStyle = grd;
    sctx.fillRect(0,0,w,h);
    sctx.globalAlpha = 1;

    requestAnimationFrame(drawCRT);
  }
  requestAnimationFrame(drawCRT);

  // ===== Waveform =====
  const waveCanvas = $("wave");
  const wctx = waveCanvas.getContext("2d");
  function drawWave(){
    const r = waveCanvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const ww = Math.max(300, Math.floor(r.width * dpr));
    const hh = Math.max(60, Math.floor(r.height * dpr));
    if (waveCanvas.width !== ww) waveCanvas.width = ww;
    if (waveCanvas.height !== hh) waveCanvas.height = hh;

    wctx.clearRect(0,0,ww,hh);
    wctx.fillStyle = "rgba(103,217,255,0.10)";
    wctx.fillRect(0,0,ww,hh);

    if(analyser && data){
      analyser.getByteTimeDomainData(data);
      wctx.strokeStyle = "rgba(207,232,255,0.80)";
      wctx.lineWidth = 2;
      wctx.beginPath();
      for(let i=0;i<data.length;i++){
        const x = (i/(data.length-1))*ww;
        const v = (data[i]-128)/128;
        const y = hh/2 + v*(hh*0.33);
        if(i===0) wctx.moveTo(x,y);
        else wctx.lineTo(x,y);
      }
      wctx.stroke();
    }else{
      wctx.strokeStyle = "rgba(207,232,255,0.30)";
      wctx.beginPath();
      wctx.moveTo(0,hh/2);
      wctx.lineTo(ww,hh/2);
      wctx.stroke();
    }

    requestAnimationFrame(drawWave);
  }
  requestAnimationFrame(drawWave);
</script>
</body>
</html>
```
